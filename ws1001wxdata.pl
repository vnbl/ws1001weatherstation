#!/usr/bin/perl -w
#
# ws1001wxdata.pl: Ver 1.8
#
# This program establishes a TCP connection with the ws1001 console and
# obtains the real time weather data generated by the sensor array.
# It writes an output file containing the ws1001 weather data in a format
# compatible with the cumulus easyweather.dat input file.
# Weather data values received from the console are expected to be given
# in US units (not metric).
# Use -m option if console displays wx data in metric units.

use utf8;
use File::Basename;
use Getopt::Std;
use Time::Local;
use IO::Socket::INET;
use Net::Domain qw(hostname hostfqdn hostdomain);
use sigtrap qw(die INT QUIT);


$dbtest = 0;

# options
$opt_d = "o_debug.txt";    # specify output debug file
$opt_m = "";    # console wx data is given in metric units
$opt_i = "";    # specify local host IP addr

getopts('md:i:');

if (@ARGV != 3)
{
    print "Usage: $0 [-m] [-i ipaddr] [-d debugfile] search_msgfile req_record_msgfile ewcumulus_file\n";
    print "Options: \n";
    print "         -m ws1001 console uses metric units (otherwise console uses US units)\n";
    print "         -i specify local host ip addr (otherwise program determines ip addr)\n";
    print "         -d specify dbug file for certain connection errors\n";
    exit -1;
}

$bcmsgfile	= $ARGV[0];	# broadcast udp search message
$sndmsgfile 	= $ARGV[1];	# message to be sent to EW console (ws1001)
$ewcumulusfile 	= $ARGV[2]; 	# output data file to be read by cumulus

my $dbugfile = $opt_d;
my $hostaddr = $opt_i;

print "*** ws1001wxdata.pl started ", scalar(localtime(time())), "\n";

##$SIG{PIPE} = sub { };

# initialize ewdat
@ewdata = ("x") x 16;
@msgcontent = ("0") x 3;

if($opt_m) { 	# console displays data in metric units
    $frztemp = 0.;
    $tfactor = 1.;
    $pfactor = 1.;
    $wfactor = 1.;
    $rfactor = 1.;
}
else {		# console displays data in US units
    $frztemp = 32.;
    $tfactor = 5./9.;
    $pfactor = 33.8639;
    $wfactor = .44704;
    $rfactor = 25.4;
}

@compass = ("N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSO", "SO", "OSO", "O", "ONO", "NO", "NNO", "N");

my $tcpport = 6500;	# tcp port	# console connection
my $udpport = 36745;	# udp port	# broadcast message port
if($dbtest) {
    $tcpport = 8888;	# tcp port
    $udpport = 7777;	# udp port
}

my $wxupdate	= 120;	# approximate wx data update interval (sec)
my $tcptimeout 	= 20;	# waiting for client connection timeout

my $maxtry	= 3;	# max attemps to write EW output file
my $trycnt 	= 0;
my $maxalrm 	= 5;	# max number of connection timeouts
my $maxreset 	= 10;	# max number of consecutive connection resets
my $resetcnt	= 0;
my $ltwd 	= 0;
my $ltyd 	= 0;
my $lti 	= 0;

open(BCM, "<", $bcmsgfile)
            || die("$0: ERROR Could not open input file, $bcmsgfile. $!\n");

@bcmsgline = (<BCM>);	# Read SEARCH UDP broadcast message
close(BCM);

open(MSG, "<", $sndmsgfile)
            || die("$0: ERROR Could not open input file, $sndmsgfile. $!\n");

@sndmsgline = (<MSG>);	# Read NOWRECORD request message to be sent to console
close(MSG);

my $host = hostname;					# Local host name
if(! $hostaddr) {
    $hostaddr = inet_ntoa(scalar gethostbyname($host));	# Local host IP addr
}

print "local host addr = $hostaddr\n";

@ipaddr = split(/\./, $hostaddr);
$bcaddr = "${ipaddr[0]}.${ipaddr[1]}.${ipaddr[2]}.255";	# local broadcast addr

if($dbtest) {
    $bcaddr = "${bcaddr}:5555";	
}
else {
    $bcaddr = "${bcaddr}:6000";     # broadcast addr
}
print "broadcast address = $bcaddr\n";

RESET:
my $sndcnt = 0;
my $alrmcnt = 0;

# auto-flush on socket
$| = 1;
 
# Create the TCP socket
my $tcpsocket = new IO::Socket::INET (
    LocalHost => $hostaddr,
    LocalPort => $tcpport,
    Proto => 'tcp',
    Listen => 5,
    Timeout  => $tcptimeout,
    Reuse => 1
);

die "Cannot create TCP socket $!\n" unless $tcpsocket;

UDPSEND:
sleep(10);

# Create the UDP Socket.
my $udpsocket = new IO::Socket::INET (
    LocalPort  => $udpport,
    PeerAddr   => $bcaddr,
    Proto        => 'udp',
    Broadcast => 1
);

die "Cannot create UDP socket $!\n" unless $udpsocket;

# Send broadcast SEARCH message
my $udpmsize = $udpsocket->send($bcmsgline[0]);
print "Sent UDP broadcast message of length $udpmsize\n";

# notify server that request has been sent
shutdown($udpsocket, 1);

$udpsocket->close();

print "Server waiting for WS1001 console connection on port $tcpport\n";

# waiting for a new client connection (WS1001 console)
$client_socket = $tcpsocket->accept();

if(! defined $client_socket) {
    $alrmcnt++;
    if($alrmcnt > $maxalrm) {
        die("$0: Timed out waiting for client (console) connection: $!\n");
    }
    goto UDPSEND;       # Send another UDP broadcast message
}
 
# get information about a newly connected client
my $client_address = $client_socket->peerhost();
my $client_port = $client_socket->peerport();
print "connection from $client_address:$client_port\n";

while(1) {	# TCP socket send/receive loop
 
    # send message to the connected client (console)
    my $rcvmsg = "";

    if(defined $client_socket->peerhost()) {
    	my $tcpmsize = $client_socket->send($sndmsgline[0]);
    	if(! $sndcnt) {
    	    print "Sent data request message to console ($tcpmsize bytes)\n";
    	}

    	# read up to 1024 characters from the connected client
    	$client_socket->recv($rcvmsg, 1024);

    	$client_msg_size = length($rcvmsg);

    	# Unpack NOWRECORD message received from console
    	(@msgcontent) = unpack("A8 A8 Z16 S C I C S C2 f14 C2", $rcvmsg);

    	$msglen = scalar(@msgcontent);
    	if(! $sndcnt) {
    	    print "Received data message from console ($client_msg_size bytes)\n";
    	    print "Received message size = $msglen \n";
	    print "... \n";
	    $sndcnt++;
    	}
    }
    else {	# console is disconnected
	print "Cannot determine peer address. \n";
	$client_msg_size = 0;
	$msglen = 0;
    }

    # Check received message properties
    if(($msglen < 24) || ($msgcontent[2] ne "NOWRECORD")) {
	if($client_msg_size) {
    	    print "Received data message ($client_msg_size bytes)\n";
	    print "Unexpected console message of size = $msglen \n";
	    
	    if($msglen > 2) {
	    	print "HP_HEAD = $msgcontent[0] \n";
	    	print "HP_CMD = $msgcontent[1] \n";
	    	print "HP_TABLE = $msgcontent[2] \n";
	    }
	    if($dbugfile) {
	    	if(open(RMG, ">", $dbugfile)) {
	    	    printf(RMG "received message: \n");
	    	    printf(RMG "%s", $rcvmsg);
	    	    close(RMG);
	    	}
	        else {
		    print "Could not open output debug file, $dbugfile. $!\n";
		    $dbugfile = "";
	        }
	    }
	}
	elsif($msglen > 0) {
	    print "Unknown response \n";
	}

	shutdown($tcpsocket, 2);
	$tcpsocket->close();

	if($resetcnt >= $maxreset) {
	    print "Program stopped: max resets = $resetcnt \n";
	    exit(2);
	}
	$resetcnt++;
	sleep(10);
 	print "*** connection reset: ", scalar(localtime(time())), "\n";
	goto RESET;	# reset TCP connection
    }
    $resetcnt = 0;

    # get current time
    ($sec, $min, $hour, $day, $month, $year, $ltwd, $ltyd, $lti) = localtime;
    $year += 1900;
    $month++;

    # Make sure rain total is reset at the beginning of the new year
    if(($month == 1) && ($day == 1) && ($hour == 0) && ( $min <= 2)) {
	$msgcontent[22] = 0.;		# console rain total
    }
    
    $strhour = sprintf ("%02d", $hour);
    $strmin = sprintf ("%02d", $min);
    $strsec = sprintf ("%02d", $sec);
	
	
    # convert date to yyyy-mm-dd format
    $ewdata[1] = "${year}-${month}-${day}";     	# date
    $ewdata[2] = "${strhour}:${strmin}:${strsec}";	# time
    

    
    # indoor humidity
    
    # if($msgcontent[8] =~ /\d/) {
      #   $ewdata[6] = sprintf("%.0f", $msgcontent[8]);
    # }
    # else { 
    $ewdata[3] = $msgcontent[8]; 
    # }

    # if required convert units from us to metric
    
    # indoor temp
    # if($msgcontent[10] =~ /\d/) {
      #   $ewdata[7] = ($msgcontent[10] - $frztemp) * $tfactor;
    # }
    # else { 
    $ewdata[4] = $msgcontent[10]; # }

    # outdoor humidity
    # if($msgcontent[9] =~ /\d/) {
    #     $ewdata[8] = sprintf("%.0f", $msgcontent[9]);
    # }
    # else { 
   
    $ewdata[5] = $msgcontent[9]; # }

    # outdoor temp
    # $ewdata[9] = (($msgcontent[13] =~ /\d/) ? (($msgcontent[13] - $frztemp) * $tfactor) : $msgcontent[13]);
	$ewdata[6] = $msgcontent[13];
    
    #dewpoint
    # $ewdata[10] = (($msgcontent[14] =~ /\d/) ? (($msgcontent[14] - $frztemp) * $tfactor) : $msgcontent[14]);

	$ewdata[7] = $msgcontent[14];
    
    # windchill
    # $ewdata[11] = (($msgcontent[15] =~ /\d/) ? (($msgcontent[15] - $frztemp) * $tfactor) : $msgcontent[15]);

	$ewdata[8] = $msgcontent[15];
    
    # barometer
    # $ewdata[13] = (($msgcontent[12] =~ /\d/) ? ($msgcontent[12] * $pfactor) : $msgcontent[12]);

	$ewdata[9] = $msgcontent[12];
    
    # wind average
    #$ewdata[14] = (($msgcontent[16] =~ /\d/) ? ($msgcontent[16] * $wfactor) : $msgcontent[16]);

	$ewdata[10] = $msgcontent[16];
    
    # wind gust
    # $ewdata[16] = (($msgcontent[17] =~ /\d/) ? ($msgcontent[17] * $wfactor) : $msgcontent[17]);

	$ewdata[11] = $msgcontent[17];
    

    # wind direction
    # Use compass for wind direction (NNO)
    $cdir = $msgcontent[7]/22.5;
    $compdir = sprintf ("%.0f", $cdir);
    $ewdata[12] = $msgcontent[7];
	
	
    # rain in last hour
    # Cumulus uses this value for rain rate (in/hour or mm/hour)
    # Use ws1001 rain rate value (in/hour or mm/hour)
    #$ewdata[23] = (($msgcontent[18] =~ /\d/) ? ($msgcontent[18] * $rfactor) : $msgcontent[18]);
    $ewdata[13] = $msgcontent[18];
    
    # rain in last year
    #$ewdata[27] = (($msgcontent[22] =~ /\d/) ? ($msgcontent[22] * $rfactor) : $msgcontent[22]);

	$ewdata[14] = $msgcontent[22];
    
    # solar radiation (Lux)
    # convert W/m2 to lux: 1 W/m2 = 126.7 lux
    #$ewdata[28] = (($msgcontent[23] =~ /\d/) ? ($msgcontent[23] * 126.7) : $msgcontent[23]);

	$ewdata[15] = $msgcontent[23];
    
    # UV Index

    $ewdata[16] = $msgcontent[24];        
    
    
    my $places = 2;
	my $factor = 10**$places;

    for($i = 3; $i < @ewdata; $i++) {
    
	$ewdata[$i] = int( $ewdata[$i] * $factor) / $factor;
    }
    
    
        
    ##################### WEBSERVICE ############################
    
      use LWP::UserAgent;
use HTTP::Request::Common;

my $ua = LWP::UserAgent->new;
my $server_endpoint = "http://tiroleo.tech/WebApi/api/trabajosclima";

my $req = HTTP::Request->new(POST => $server_endpoint);
$req->header('content-type' => 'text/json');

my $post_data = join('','{ "FECHA_ALTA": "', $ewdata[1],'T', $ewdata[2],'", "TEMPERATURA": ', $ewdata[6], ' ,
"HUMEDAD": ' ,$ewdata[5],', "VIENTO": ', $ewdata[11], ', "MAXIMA_VIENTO": ', $ewdata[10],', "LLUVIA": ', $ewdata[13], ', "SOL": ', $ewdata[15],
', "BAROMETRO": ', $ewdata[9] ,', "PUNTO_DE_ROCIO": ', $ewdata[7],', "SENSACION_TERMICA": ',$ewdata[8],', "VELOCIDAD_VIENTO_PROMEDIO": ', $ewdata[10], 
', "VELOCIDAD_MAXIMA": ', $ewdata[11], ', "DIRECCION_DEL_VIENTO": ', $ewdata[12], ', "LLUVIA_ULTIMA_HORA": ', $ewdata[13], ', "LLUVIA_ULTIMO_ANHO": ', $ewdata[14], 
', "LATITUD": -25.26303300, "LONGITUD": -57.58180900, "NOMBRE_ESTACION": "ESTACION FECOPROD"', 
' , "ET": 1 , "UV": ', $ewdata[16], ', "ID": 1}');

$req->content($post_data);

print $req->as_string;

my $resp = $ua->request($req);
if ($resp->is_success) {
    my $message = $resp->decoded_content;
    print "Received reply: $message\n";
}
else {
    print "HTTP POST error code: ", $resp->code, "\n";
    print "HTTP POST error message: ", $resp->message, "\n";
}

    
    ################### END WEBSERVICE #####################
              

    if(open(EWP, ">", $ewcumulusfile)) {
        $trycnt = 0;
    }
    elsif($trycnt < $maxtry) {
        $trycnt++;
        print "$0 : ", scalar(localtime(time())), "\n";
        print "$0 - could not open output file, will try again ($trycnt)\n";
        sleep(60);
        next;
    }
    else {
        die("$0: ERROR Could not open output file, $ewcumulusfile. $!\n");
    }

	
	
	
	
	###### IMPRESION JSON #######
	
	printf(EWP "%s " , "{ \n\n  ");
	printf(EWP "%20s \n" , ' "lectura_por_hora":{ ');
	
	printf(EWP "%20s " , '	"observation_time":"Last Updated on ');
	printf(EWP "%s " , $ewdata[1]);
	printf(EWP "%s " , $ewdata[2]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s" , '	"indoor_humidity":"');
	printf(EWP "%s " , $ewdata[3]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s" , '	"indoor_temperature":"');
	printf(EWP "%s " , $ewdata[4]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s" , '	"outdoor_humidity":"');
	printf(EWP "%s " , $ewdata[5]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s" , '	"outdoor_temperature":"');
	printf(EWP "%s " , $ewdata[6]);
	printf(EWP "%s \n" , '",');

	printf(EWP "%20s", '	"dewpoint":"');
	printf(EWP "%s " , $ewdata[7]);
	printf(EWP "%s \n " , '",');
   
    
    printf(EWP "%20s", '	"windchill":"');
	printf(EWP "%s " , $ewdata[8]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s" , '	"pressure":"');
	printf(EWP "%s " , $ewdata[9]);
	printf(EWP "%s \n" , '",');

	
	printf(EWP "%20s " , '	"wind_average":"');
	printf(EWP "%s " , $ewdata[10]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '	"wind_gust":"');
	printf(EWP "%s " , $ewdata[11]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '	"wind_direction":"');
	printf(EWP "%s " , $ewdata[12]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '	"precip_week":"');
	printf(EWP "%s " , $ewdata[13]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '	"precip_year":"');
	printf(EWP "%s " , $ewdata[14]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '	"solar_radiation":"');
	printf(EWP "%s " , $ewdata[15]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s " , '"UV":"');
	printf(EWP "%s " , $ewdata[16]);
	printf(EWP "%s \n" , '",');
	
	printf(EWP "%20s \n", ' } ');
	printf(EWP "%-20s \n", ' } ');
	
	close(EWP);
    sleep($wxupdate);
}
 
$tcpsocket->close();



exit(0);
